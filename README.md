## Java JSON Parser

Это проект парсера JSON на основе Java 21. Он предоставляет удобный способ кодирования, анализа и обработки данных JSON.

Поддерживаемые функции включают:
- Кодирование данных JSON: этот проект поддерживает кодирование объектов Java в строки JSON;
- Анализ данных JSON: этот проект поддерживает анализ строк JSON в объекты Java для удобства обработки и операций в коде;
- Поддержка базовых типов данных: этот проект поддерживает обработку строк, чисел, булевых значений и нулевых значений в JSON;
- Поддержка сложных структур данных: этот проект поддерживает обработку объектов и массивов в JSON, позволяя вложенность и многоуровневые структуры;
- Гибкий доступ к данным: этот проект предоставляет простой и гибкий API для удобного доступа и обработки анализированных данных JSON.

Ниже приведен простой пример, демонстрирующий использование этого парсера для кодирования/анализа данных JSON:

```java
import jsonp.*;

public class App {
    public static void main(String[] args) {
        List<Map<String, Integer>> data = List.of(Map.of("A test", 1, "B", 2), Map.of("C", 3));
        System.out.println("Raw: " + data);
        String encoded = Encoder.encode(data);
        Decoder decoder = new Decoder();
        System.out.println("Encoded: " + encoded);
        JsonObject decoded = decoder.decode(encoded);
        System.out.println("Decoded: " + decoded);
    }
}
```

### Кодировщик Encoder

По умолчанию кодировщик поддерживает следующие типы данных:

- Java Null ссылки: `null`
- Java базовые типы данных: `byte, short, int, long, float, double, boolean, char`
- Java Boxed типы: `Number, Boolean, Character, String`
- Java контейнерные типы: `List<?>, Map<String, ?>`

Конечно, вы можете реализовать собственный метод кодирования для своего класса, просто зарегистрировав кодировщик с помощью `Encoder.register`:

```java
class Foo {
    public String name;
    public String ID;
}
Encoder.register(Foo.class, obj -> {
    Foo foo = (Foo) obj;
    return Encoder.encode(Map.of("name", foo.name, "ID", foo.ID));
});
```

Обратите внимание, что в функции кодирования вы получаете объект `Object`, который вам нужно преобразовать в тип, возвращая в конце концов закодированную строку (конечно, вы можете рекурсивно использовать поддерживаемые кодировщики для получения строки JSON из атрибутов класса).

### Декодер Decoder

Чтобы использовать декодер, вам нужно создать объект `jsonp.decoder.Decoder` и передать ему содержимое для декодирования.

Все результаты, полученные после декодирования, являются объектом `JsonObject` (включая содержимое контейнерного типа), в котором, в зависимости от его фактического содержимого, в `JsonObject.object` хранится фактическое содержимое, и вы можете использовать метод `as` для его преобразования в тип, который, как вы думаете, он действительно содержит. Поэтому, кроме базовых типов, вы также можете получить следующие типы контейнеров:

- `List<JsonObject>` - это соответствует массиву JSON;
- `Map<String, JsonObject>` - это соответствует карте JSON;

Если вам нужно получить доступ к элементам внутри контейнерного типа, не забудьте преобразовать его в тип, который вам нужен, как показано ниже:

```Java
List<Integer> items = List.of(1, 2, 3, 4, 5);
String encoded = Encoder.encode(items);
Decoder decoder = new Decoder();
List<JsonObject> decoded = decoder.decode(encoded);
for (JsonObject obj : decoded) {
    Integer item = obj.as();
    System.out.println("%d", item);
}
```

### Реализация

Проект состоит из четырех основных частей: простой движок регулярных выражений на основе NFA, Tokenizer, Parser и Encoder.

#### NFA и регулярные выражения

Базовые элементы, составляющие строку JSON, можно описать с помощью простого регулярного выражения. Например, для допустимых чисел, принимаемых синтаксисом, его регулярное выражение выглядит примерно так:

```js
-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?
```

Таким образом, как первый шаг в реализации Decoder, нам нужно реализовать "мини-версию" движка регулярных выражений, который скажет нам, является ли каждая часть входной строки частью элементов синтаксиса JSON.

Что касается регулярных выражений, их базовые элементы составляют следующее:

- `Epsilon` - это позволит появление пустого элемента
- `a|b` - это позволит движку принимать любой элемент из `a` или `b`
- `ab` - это скажет движку, что мы хотим видеть `a`, сразу следующее за `b`
- `a*` - это также называется замыканием Кленне, которое позволяет `a` появляться любое количество раз (включая 0 раз)

Да, это основные элементы регулярных выражений. Что касается `+, ?, {n, m}, ...` и других таких синтаксисов, они могут рассматриваться как комбинации этих основных элементов (вы можете называть их Syntax Sugar).

Все эти элементы (и синтаксический сахар) получаются в `jsonp.regex`.

Оставшаяся задача - это анализ регулярного выражения в NFA, так что мы можем использовать его для распознавания входной строки. К счастью, алгоритм Томпсона дает способ построения NFA на основе этих базовых элементов. В `jsonp.automata.NFA` я реализовал этот алгоритм.

На самом деле можно преобразовать NFA в эквивалентный DFA (алгоритм Subset Construction может помочь нам в этом). Это будет более эффективно во время выполнения, но для начальной версии парсера JSON NFA вполне достаточно.

#### NFA и Tokenizer

Получив NFA каждого базового элемента синтаксиса JSON, нам нужно написать Tokenizer, чтобы соединить их вместе, чтобы обработать ввод конечного пользователя. На самом деле это довольно просто: нам просто нужно создать начальное состояние и соединить начальные состояния этих базовых элементов с помощью пустого перехода (то есть ранее упомянутого элемента Epsilon) - таким образом, когда NFA ожидает ввод, мы можем считать, что все начальные состояния базовых элементов ожидают проверки.

Чтобы подтвердить, что текущий ввод достиг конца, нам также нужно отметить все конечные состояния базовых элементов. Таким образом, когда Tokenizer обнаруживает, что ни одно из состояний не может принять текущий ввод, он остановится, вернется назад и посмотрит, что было последним состоянием, принявшим элемент - и это даст анализированный базовый элемент.

Что касается синтаксиса JSON, его Tokenizer соответствует следующему NFA (вы также можете использовать `NFA.draw` для печати на консоли и посмотреть, это хороший способ DEBUG):

![NFA](https://github.com/guiqiqi/java-jsonp/blob/master/README.assets/NFA.png?raw=true)

На самом деле, кроме обработки чисел, все довольно просто.

Эта часть кода в основном реализована в `jsonp.decoder.Lexer`.

#### Parser

Получив базовые элементы после обработки Tokenizer (они на самом деле имеют имя Token), нам нужно проверить, соответствует ли их комбинация синтаксису JSON. Синтаксис JSON довольно прост, он может быть выражен в форме BNF:

```javascript
<json> ::= <primitive> | <container>
<primitive> ::= <number> | <string> | <boolean>
<container> ::= <object> | <array>
<array> ::= '[' [ <json> *(', ' <json>) ] ']'
<object> ::= '{' [ <member> *(', ' <member>) ] '}'
<member> ::= <string> ': ' <json>
```

Это выглядит очень интуитивно. Более того, это контекстно-независимая грамматика. Чтобы сделать его более удобным для реализации кода, мы преобразуем его в другую эквивалентную версию (здесь используется форма Chomsky):

```javascript
obj -> { members }
members -> pair members' | eps
members' -> , pair members' | eps
pair -> string : value
array -> [ elem ]
elem -> value elem' | eps
elem' -> , value elem' | eps
value -> obj | array | number | string | true | false | null
```

В чем разница между этой версией и предыдущей? Мы преобразовали его в грамматику LL(1). Какие преимущества это дает? На самом деле это означает, что эту грамматику можно анализировать с помощью парсера LL(1). Обычно есть два способа анализировать такую грамматику: метод рекурсивного спуска и метод LL(1) с использованием таблицы, и первый из них относительно прост, поэтому в `jsonp.decoder.Parser` я использовал рекурсивный спуск для анализа потока Token, полученного на предыдущем шаге.

На этом реализация Decoder в основном завершена.

#### Encoder 

По сравнению с Decoder, реализация Encoder гораздо проще:

```java
public static String encode(Object obj) {
    if (obj == null)
        return "null";
    Class<?> type = obj.getClass();
    Function<Object, String> encoder = Encoders.get(type);
    if (encoder != null)
        return encoder.apply(obj);
    for (Map.Entry<Class<?>, Function<Object, String>> entry : Encoders.entrySet()) {
        if (entry.getKey().isAssignableFrom(type)) {
            return entry.getValue().apply(obj);
        }
    }
    return obj.toString();
}
```

`Encoders` - это статическая переменная класса, которая поддерживает отображение класса на его функцию encoder. Функция `encoder` каждый раз проверяет, есть ли у текущего объекта заданная функция encoder в `Encoders` - если есть, она просто использует ее и возвращает закодированную строку JSON; если нет, она попытается узнать, есть ли у Assignable класса функция encoder, и если есть, она вызовет ее. А для совершенно "незнакомых" классов она попытается прямо вызвать метод `toString` для последней "помощи" - конечно, это не гарантирует, что кодирование будет правильным, поэтому для пользовательских классов вам нужно вызвать `Encoder.register` для регистрации своего собственного encoder.

Это в основном вся реализация.